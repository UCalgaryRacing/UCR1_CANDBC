/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 39.4.8 Mon Nov 11 12:41:31 2024.
 */

#ifndef UCR_01_H
#define UCR_01_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define UCR_01_FRONT_ANALOG_FRAME_ID (0x103u)
#define UCR_01_REAR_ANALOG_FRAME_ID (0x102u)
#define UCR_01_FRONT_AERO_FRAME_ID (0x600u)
#define UCR_01_REAR_AERO_FRAME_ID (0x601u)
#define UCR_01_ENCODER_POSITIONS_FRAME_ID (0xc8u)
#define UCR_01_FRONT_STRAIN_GAUGES1_FRAME_ID (0x610u)
#define UCR_01_FRONT_STRAIN_GAUGES2_FRAME_ID (0x611u)
#define UCR_01_REAR_STRAIN_GAUGES1_FRAME_ID (0x612u)
#define UCR_01_REAR_STRAIN_GAUGES2_FRAME_ID (0x613u)
#define UCR_01_GPS_BEST_POS_FRAME_ID (0x50u)
#define UCR_01_FRONT_FREQUENCY_FRAME_ID (0x65u)
#define UCR_01_REAR_FREQUENCY_FRAME_ID (0x66u)
#define UCR_01_BAMOCAR_RX_DATA_FRAME_ID (0x201u)
#define UCR_01_CELL_VOLTAGE1_FRAME_ID (0x32u)
#define UCR_01_CELL_VOLTAGE2_FRAME_ID (0x33u)
#define UCR_01_CELL_VOLTAGE3_FRAME_ID (0x34u)
#define UCR_01_CELL_VOLTAGE4_FRAME_ID (0x35u)
#define UCR_01_CELL_VOLTAGE5_FRAME_ID (0x36u)
#define UCR_01_CELL_VOLTAGE6_FRAME_ID (0x37u)
#define UCR_01_CELL_VOLTAGE7_FRAME_ID (0x38u)
#define UCR_01_CELL_VOLTAGE8_FRAME_ID (0x39u)
#define UCR_01_THERMISTOR1_FRAME_ID (0x3cu)
#define UCR_01_THERMISTOR2_FRAME_ID (0x3du)
#define UCR_01_THERMISTOR3_FRAME_ID (0x3eu)
#define UCR_01_THERMISTOR4_FRAME_ID (0x3fu)
#define UCR_01_THERMISTOR5_FRAME_ID (0x40u)
#define UCR_01_THERMISTOR6_FRAME_ID (0x41u)
#define UCR_01_THERMISTOR7_FRAME_ID (0x42u)
#define UCR_01_THERMISTOR8_FRAME_ID (0x43u)
#define UCR_01_THERMISTOR9_FRAME_ID (0x44u)
#define UCR_01_THERMISTOR10_FRAME_ID (0x45u)
#define UCR_01_THERMISTOR11_FRAME_ID (0x46u)
#define UCR_01_THERMISTOR12_FRAME_ID (0x47u)
#define UCR_01_PACK_VOLTAGE_FRAME_ID (0x05u)
#define UCR_01_TCU1_FRAME_ID (0x06u)
#define UCR_01_TCU2_FRAME_ID (0x64u)
#define UCR_01_ACULV_FD_1_FRAME_ID (0x08u)
#define UCR_01_ACULV_FD_2_FRAME_ID (0x1eu)
#define UCR_01_ACULV1_FRAME_ID (0x28u)
#define UCR_01_ACULV2_FRAME_ID (0x29u)
#define UCR_01_PDM1_FRAME_ID (0x500u)
#define UCR_01_BAMOCAR_TX_DATA_FRAME_ID (0x181u)
#define UCR_01_INS_GPS_FRAME_ID (0x51u)
#define UCR_01_INS_IMU_FRAME_ID (0x52u)
#define UCR_01_BAMO_CAR_RE_TRANSMIT_FRAME_ID (0x258u)
#define UCR_01_PDM_CURRENT_FRAME_ID (0x520u)
#define UCR_01_PDM_RE_TRANSMIT_FRAME_ID (0x690u)
#define UCR_01_PACK_POWER_FRAME_ID (0x04u)
#define UCR_01_BAMO_CAR_CONVERTED_FRAME_ID (0x691u)
#define UCR_01_LAP_INFO_FRAME_ID (0x3e8u)
#define UCR_01_POWER_LIMIT_INFO1_FRAME_ID (0x0au)
#define UCR_01_POWER_LIMIT_INFO2_FRAME_ID (0x0bu)

/* Frame lengths in bytes. */
#define UCR_01_FRONT_ANALOG_LENGTH (16u)
#define UCR_01_REAR_ANALOG_LENGTH (16u)
#define UCR_01_FRONT_AERO_LENGTH (16u)
#define UCR_01_REAR_AERO_LENGTH (16u)
#define UCR_01_ENCODER_POSITIONS_LENGTH (8u)
#define UCR_01_FRONT_STRAIN_GAUGES1_LENGTH (20u)
#define UCR_01_FRONT_STRAIN_GAUGES2_LENGTH (20u)
#define UCR_01_REAR_STRAIN_GAUGES1_LENGTH (20u)
#define UCR_01_REAR_STRAIN_GAUGES2_LENGTH (20u)
#define UCR_01_GPS_BEST_POS_LENGTH (64u)
#define UCR_01_FRONT_FREQUENCY_LENGTH (16u)
#define UCR_01_REAR_FREQUENCY_LENGTH (16u)
#define UCR_01_BAMOCAR_RX_DATA_LENGTH (6u)
#define UCR_01_CELL_VOLTAGE1_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE2_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE3_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE4_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE5_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE6_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE7_LENGTH (64u)
#define UCR_01_CELL_VOLTAGE8_LENGTH (64u)
#define UCR_01_THERMISTOR1_LENGTH (64u)
#define UCR_01_THERMISTOR2_LENGTH (64u)
#define UCR_01_THERMISTOR3_LENGTH (64u)
#define UCR_01_THERMISTOR4_LENGTH (64u)
#define UCR_01_THERMISTOR5_LENGTH (64u)
#define UCR_01_THERMISTOR6_LENGTH (64u)
#define UCR_01_THERMISTOR7_LENGTH (64u)
#define UCR_01_THERMISTOR8_LENGTH (64u)
#define UCR_01_THERMISTOR9_LENGTH (64u)
#define UCR_01_THERMISTOR10_LENGTH (64u)
#define UCR_01_THERMISTOR11_LENGTH (64u)
#define UCR_01_THERMISTOR12_LENGTH (64u)
#define UCR_01_PACK_VOLTAGE_LENGTH (4u)
#define UCR_01_TCU1_LENGTH (16u)
#define UCR_01_TCU2_LENGTH (1u)
#define UCR_01_ACULV_FD_1_LENGTH (24u)
#define UCR_01_ACULV_FD_2_LENGTH (8u)
#define UCR_01_ACULV1_LENGTH (8u)
#define UCR_01_ACULV2_LENGTH (1u)
#define UCR_01_PDM1_LENGTH (8u)
#define UCR_01_BAMOCAR_TX_DATA_LENGTH (6u)
#define UCR_01_INS_GPS_LENGTH (48u)
#define UCR_01_INS_IMU_LENGTH (64u)
#define UCR_01_BAMO_CAR_RE_TRANSMIT_LENGTH (4u)
#define UCR_01_PDM_CURRENT_LENGTH (8u)
#define UCR_01_PDM_RE_TRANSMIT_LENGTH (6u)
#define UCR_01_PACK_POWER_LENGTH (12u)
#define UCR_01_BAMO_CAR_CONVERTED_LENGTH (8u)
#define UCR_01_LAP_INFO_LENGTH (5u)
#define UCR_01_POWER_LIMIT_INFO1_LENGTH (8u)
#define UCR_01_POWER_LIMIT_INFO2_LENGTH (8u)

/* Extended or standard frame types. */
#define UCR_01_FRONT_ANALOG_IS_EXTENDED (0)
#define UCR_01_REAR_ANALOG_IS_EXTENDED (0)
#define UCR_01_FRONT_AERO_IS_EXTENDED (0)
#define UCR_01_REAR_AERO_IS_EXTENDED (0)
#define UCR_01_ENCODER_POSITIONS_IS_EXTENDED (0)
#define UCR_01_FRONT_STRAIN_GAUGES1_IS_EXTENDED (0)
#define UCR_01_FRONT_STRAIN_GAUGES2_IS_EXTENDED (0)
#define UCR_01_REAR_STRAIN_GAUGES1_IS_EXTENDED (0)
#define UCR_01_REAR_STRAIN_GAUGES2_IS_EXTENDED (0)
#define UCR_01_GPS_BEST_POS_IS_EXTENDED (0)
#define UCR_01_FRONT_FREQUENCY_IS_EXTENDED (0)
#define UCR_01_REAR_FREQUENCY_IS_EXTENDED (0)
#define UCR_01_BAMOCAR_RX_DATA_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE1_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE2_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE3_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE4_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE5_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE6_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE7_IS_EXTENDED (0)
#define UCR_01_CELL_VOLTAGE8_IS_EXTENDED (0)
#define UCR_01_THERMISTOR1_IS_EXTENDED (0)
#define UCR_01_THERMISTOR2_IS_EXTENDED (0)
#define UCR_01_THERMISTOR3_IS_EXTENDED (0)
#define UCR_01_THERMISTOR4_IS_EXTENDED (0)
#define UCR_01_THERMISTOR5_IS_EXTENDED (0)
#define UCR_01_THERMISTOR6_IS_EXTENDED (0)
#define UCR_01_THERMISTOR7_IS_EXTENDED (0)
#define UCR_01_THERMISTOR8_IS_EXTENDED (0)
#define UCR_01_THERMISTOR9_IS_EXTENDED (0)
#define UCR_01_THERMISTOR10_IS_EXTENDED (0)
#define UCR_01_THERMISTOR11_IS_EXTENDED (0)
#define UCR_01_THERMISTOR12_IS_EXTENDED (0)
#define UCR_01_PACK_VOLTAGE_IS_EXTENDED (0)
#define UCR_01_TCU1_IS_EXTENDED (0)
#define UCR_01_TCU2_IS_EXTENDED (0)
#define UCR_01_ACULV_FD_1_IS_EXTENDED (0)
#define UCR_01_ACULV_FD_2_IS_EXTENDED (0)
#define UCR_01_ACULV1_IS_EXTENDED (0)
#define UCR_01_ACULV2_IS_EXTENDED (0)
#define UCR_01_PDM1_IS_EXTENDED (0)
#define UCR_01_BAMOCAR_TX_DATA_IS_EXTENDED (0)
#define UCR_01_INS_GPS_IS_EXTENDED (0)
#define UCR_01_INS_IMU_IS_EXTENDED (0)
#define UCR_01_BAMO_CAR_RE_TRANSMIT_IS_EXTENDED (0)
#define UCR_01_PDM_CURRENT_IS_EXTENDED (0)
#define UCR_01_PDM_RE_TRANSMIT_IS_EXTENDED (0)
#define UCR_01_PACK_POWER_IS_EXTENDED (0)
#define UCR_01_BAMO_CAR_CONVERTED_IS_EXTENDED (0)
#define UCR_01_LAP_INFO_IS_EXTENDED (0)
#define UCR_01_POWER_LIMIT_INFO1_IS_EXTENDED (0)
#define UCR_01_POWER_LIMIT_INFO2_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */


/* Frame Names. */
#define UCR_01_FRONT_ANALOG_NAME "FrontAnalog"
#define UCR_01_REAR_ANALOG_NAME "RearAnalog"
#define UCR_01_FRONT_AERO_NAME "FrontAero"
#define UCR_01_REAR_AERO_NAME "RearAero"
#define UCR_01_ENCODER_POSITIONS_NAME "EncoderPositions"
#define UCR_01_FRONT_STRAIN_GAUGES1_NAME "FrontStrainGauges1"
#define UCR_01_FRONT_STRAIN_GAUGES2_NAME "FrontStrainGauges2"
#define UCR_01_REAR_STRAIN_GAUGES1_NAME "RearStrainGauges1"
#define UCR_01_REAR_STRAIN_GAUGES2_NAME "RearStrainGauges2"
#define UCR_01_GPS_BEST_POS_NAME "GPSBestPos"
#define UCR_01_FRONT_FREQUENCY_NAME "FrontFrequency"
#define UCR_01_REAR_FREQUENCY_NAME "RearFrequency"
#define UCR_01_BAMOCAR_RX_DATA_NAME "BamocarRxData"
#define UCR_01_CELL_VOLTAGE1_NAME "CellVoltage1"
#define UCR_01_CELL_VOLTAGE2_NAME "CellVoltage2"
#define UCR_01_CELL_VOLTAGE3_NAME "CellVoltage3"
#define UCR_01_CELL_VOLTAGE4_NAME "CellVoltage4"
#define UCR_01_CELL_VOLTAGE5_NAME "CellVoltage5"
#define UCR_01_CELL_VOLTAGE6_NAME "CellVoltage6"
#define UCR_01_CELL_VOLTAGE7_NAME "CellVoltage7"
#define UCR_01_CELL_VOLTAGE8_NAME "CellVoltage8"
#define UCR_01_THERMISTOR1_NAME "Thermistor1"
#define UCR_01_THERMISTOR2_NAME "Thermistor2"
#define UCR_01_THERMISTOR3_NAME "Thermistor3"
#define UCR_01_THERMISTOR4_NAME "Thermistor4"
#define UCR_01_THERMISTOR5_NAME "Thermistor5"
#define UCR_01_THERMISTOR6_NAME "Thermistor6"
#define UCR_01_THERMISTOR7_NAME "Thermistor7"
#define UCR_01_THERMISTOR8_NAME "Thermistor8"
#define UCR_01_THERMISTOR9_NAME "Thermistor9"
#define UCR_01_THERMISTOR10_NAME "Thermistor10"
#define UCR_01_THERMISTOR11_NAME "Thermistor11"
#define UCR_01_THERMISTOR12_NAME "Thermistor12"
#define UCR_01_PACK_VOLTAGE_NAME "PackVoltage"
#define UCR_01_TCU1_NAME "TCU1"
#define UCR_01_TCU2_NAME "TCU2"
#define UCR_01_ACULV_FD_1_NAME "ACULV_FD_1"
#define UCR_01_ACULV_FD_2_NAME "ACULV_FD_2"
#define UCR_01_ACULV1_NAME "ACULV1"
#define UCR_01_ACULV2_NAME "ACULV2"
#define UCR_01_PDM1_NAME "PDM1"
#define UCR_01_BAMOCAR_TX_DATA_NAME "BamocarTxData"
#define UCR_01_INS_GPS_NAME "INS_GPS"
#define UCR_01_INS_IMU_NAME "INS_IMU"
#define UCR_01_BAMO_CAR_RE_TRANSMIT_NAME "BamoCarReTransmit"
#define UCR_01_PDM_CURRENT_NAME "PDMCurrent"
#define UCR_01_PDM_RE_TRANSMIT_NAME "PDMReTransmit"
#define UCR_01_PACK_POWER_NAME "PackPower"
#define UCR_01_BAMO_CAR_CONVERTED_NAME "BamoCarConverted"
#define UCR_01_LAP_INFO_NAME "LapInfo"
#define UCR_01_POWER_LIMIT_INFO1_NAME "Power_Limit_Info1"
#define UCR_01_POWER_LIMIT_INFO2_NAME "Power_Limit_Info2"

/* Signal Names. */
#define UCR_01_FRONT_ANALOG_LEFT_RAD_NAME "LeftRad"
#define UCR_01_FRONT_ANALOG_RIGHT_RAD_NAME "RightRad"
#define UCR_01_FRONT_ANALOG_FRONT_RIGHT_POT_NAME "FrontRightPot"
#define UCR_01_FRONT_ANALOG_FRONT_LEFT_POT_NAME "FrontLeftPot"
#define UCR_01_FRONT_ANALOG_REAR_RIGHT_POT_NAME "RearRightPot"
#define UCR_01_FRONT_ANALOG_REAR_LEFT_POT_NAME "RearLeftPot"
#define UCR_01_FRONT_ANALOG_STEERING_ANGLE_NAME "SteeringAngle"
#define UCR_01_FRONT_ANALOG_ANALOG8_NAME "Analog8"
#define UCR_01_REAR_ANALOG_ANALOG1_NAME "Analog1"
#define UCR_01_REAR_ANALOG_ANALOG2_NAME "Analog2"
#define UCR_01_REAR_ANALOG_ANALOG3_NAME "Analog3"
#define UCR_01_REAR_ANALOG_ANALOG4_NAME "Analog4"
#define UCR_01_REAR_ANALOG_ANALOG5_NAME "Analog5"
#define UCR_01_REAR_ANALOG_ANALOG6_NAME "Analog6"
#define UCR_01_REAR_ANALOG_ANALOG7_NAME "Analog7"
#define UCR_01_REAR_ANALOG_ANALOG8_NAME "Analog8"
#define UCR_01_FRONT_AERO_PRESSURE1_NAME "Pressure1"
#define UCR_01_FRONT_AERO_PRESSURE2_NAME "Pressure2"
#define UCR_01_FRONT_AERO_PRESSURE3_NAME "Pressure3"
#define UCR_01_FRONT_AERO_TEMPERATURE1_NAME "Temperature1"
#define UCR_01_FRONT_AERO_TEMPERATURE2_NAME "Temperature2"
#define UCR_01_FRONT_AERO_TEMPERATURE3_NAME "Temperature3"
#define UCR_01_REAR_AERO_PRESSURE1_NAME "Pressure1"
#define UCR_01_REAR_AERO_PRESSURE2_NAME "Pressure2"
#define UCR_01_REAR_AERO_PRESSURE3_NAME "Pressure3"
#define UCR_01_REAR_AERO_TEMPERATURE1_NAME "Temperature1"
#define UCR_01_REAR_AERO_TEMPERATURE2_NAME "Temperature2"
#define UCR_01_REAR_AERO_TEMPERATURE3_NAME "Temperature3"
#define UCR_01_ENCODER_POSITIONS_ENCODER1_NAME "Encoder1"
#define UCR_01_ENCODER_POSITIONS_ENCODER2_NAME "Encoder2"
#define UCR_01_ENCODER_POSITIONS_ENCODER3_NAME "Encoder3"
#define UCR_01_ENCODER_POSITIONS_ENCODER4_NAME "Encoder4"
#define UCR_01_FRONT_STRAIN_GAUGES1_FLPR_NAME "FLPR"
#define UCR_01_FRONT_STRAIN_GAUGES1_FLRU_NAME "FLRU"
#define UCR_01_FRONT_STRAIN_GAUGES1_FLFL_NAME "FLFL"
#define UCR_01_FRONT_STRAIN_GAUGES1_FLRL_NAME "FLRL"
#define UCR_01_FRONT_STRAIN_GAUGES1_FLFU_NAME "FLFU"
#define UCR_01_FRONT_STRAIN_GAUGES1_FLS_NAME "FLS"
#define UCR_01_FRONT_STRAIN_GAUGES2_FRS_NAME "FRS"
#define UCR_01_FRONT_STRAIN_GAUGES2_FRFU_NAME "FRFU"
#define UCR_01_FRONT_STRAIN_GAUGES2_FRFL_NAME "FRFL"
#define UCR_01_FRONT_STRAIN_GAUGES2_FRRL_NAME "FRRL"
#define UCR_01_FRONT_STRAIN_GAUGES2_FRRU_NAME "FRRU"
#define UCR_01_FRONT_STRAIN_GAUGES2_FRPR_NAME "FRPR"
#define UCR_01_REAR_STRAIN_GAUGES1_RRT_NAME "RRT"
#define UCR_01_REAR_STRAIN_GAUGES1_RRRL_NAME "RRRL"
#define UCR_01_REAR_STRAIN_GAUGES1_RRRU_NAME "RRRU"
#define UCR_01_REAR_STRAIN_GAUGES1_RRFL_NAME "RRFL"
#define UCR_01_REAR_STRAIN_GAUGES1_RRFU_NAME "RRFU"
#define UCR_01_REAR_STRAIN_GAUGES1_RRPR_NAME "RRPR"
#define UCR_01_REAR_STRAIN_GAUGES2_RLFL_NAME "RLFL"
#define UCR_01_REAR_STRAIN_GAUGES2_RLFU_NAME "RLFU"
#define UCR_01_REAR_STRAIN_GAUGES2_RLPR_NAME "RLPR"
#define UCR_01_REAR_STRAIN_GAUGES2_RLRU_NAME "RLRU"
#define UCR_01_REAR_STRAIN_GAUGES2_RLRL_NAME "RLRL"
#define UCR_01_REAR_STRAIN_GAUGES2_RLT_NAME "RLT"
#define UCR_01_GPS_BEST_POS_LATITUDE_NAME "Latitude"
#define UCR_01_GPS_BEST_POS_LONGITUDE_NAME "Longitude"
#define UCR_01_GPS_BEST_POS_ALTITUDE_NAME "Altitude"
#define UCR_01_GPS_BEST_POS_STD_LATITUDE_NAME "stdLatitude"
#define UCR_01_GPS_BEST_POS_STD_LONGITUDE_NAME "stdLongitude"
#define UCR_01_GPS_BEST_POS_STD_ALTITUDE_NAME "stdAltitude"
#define UCR_01_GPS_BEST_POS_GPS_STATUS_NAME "gpsStatus"
#define UCR_01_FRONT_FREQUENCY_REAR_RIGHT_NAME "RearRight"
#define UCR_01_FRONT_FREQUENCY_FRONT_RIGHT_NAME "FrontRight"
#define UCR_01_FRONT_FREQUENCY_REAR_LEFT_NAME "RearLeft"
#define UCR_01_FRONT_FREQUENCY_FRONT_LEFT_NAME "FrontLeft"
#define UCR_01_REAR_FREQUENCY_FREQ1_NAME "Freq1"
#define UCR_01_REAR_FREQUENCY_FREQ2_NAME "Freq2"
#define UCR_01_REAR_FREQUENCY_FREQ3_NAME "Freq3"
#define UCR_01_REAR_FREQUENCY_FREQ4_NAME "Freq4"
#define UCR_01_BAMOCAR_RX_DATA_REGID_NAME "REGID"
#define UCR_01_BAMOCAR_RX_DATA_BYTE1_NAME "Byte1"
#define UCR_01_BAMOCAR_RX_DATA_BYTE2_NAME "Byte2"
#define UCR_01_BAMOCAR_RX_DATA_BYTE3_NAME "Byte3"
#define UCR_01_BAMOCAR_RX_DATA_BYTE4_NAME "Byte4"
#define UCR_01_BAMOCAR_RX_DATA_BYTE5_NAME "Byte5"
#define UCR_01_CELL_VOLTAGE1_CELL1_NAME "Cell1"
#define UCR_01_CELL_VOLTAGE1_CELL2_NAME "Cell2"
#define UCR_01_CELL_VOLTAGE1_CELL3_NAME "Cell3"
#define UCR_01_CELL_VOLTAGE1_CELL4_NAME "Cell4"
#define UCR_01_CELL_VOLTAGE1_CELL5_NAME "Cell5"
#define UCR_01_CELL_VOLTAGE1_CELL6_NAME "Cell6"
#define UCR_01_CELL_VOLTAGE1_CELL7_NAME "Cell7"
#define UCR_01_CELL_VOLTAGE1_CELL8_NAME "Cell8"
#define UCR_01_CELL_VOLTAGE1_CELL9_NAME "Cell9"
#define UCR_01_CELL_VOLTAGE1_CELL10_NAME "Cell10"
#define UCR_01_CELL_VOLTAGE1_CELL11_NAME "Cell11"
#define UCR_01_CELL_VOLTAGE1_CELL12_NAME "Cell12"
#define UCR_01_CELL_VOLTAGE1_CELL13_NAME "Cell13"
#define UCR_01_CELL_VOLTAGE1_CELL14_NAME "Cell14"
#define UCR_01_CELL_VOLTAGE1_CELL15_NAME "Cell15"
#define UCR_01_CELL_VOLTAGE1_CELL16_NAME "Cell16"
#define UCR_01_CELL_VOLTAGE2_CELL17_NAME "Cell17"
#define UCR_01_CELL_VOLTAGE2_CELL18_NAME "Cell18"
#define UCR_01_CELL_VOLTAGE2_CELL19_NAME "Cell19"
#define UCR_01_CELL_VOLTAGE2_CELL20_NAME "Cell20"
#define UCR_01_CELL_VOLTAGE2_CELL21_NAME "Cell21"
#define UCR_01_CELL_VOLTAGE2_CELL22_NAME "Cell22"
#define UCR_01_CELL_VOLTAGE2_CELL23_NAME "Cell23"
#define UCR_01_CELL_VOLTAGE2_CELL24_NAME "Cell24"
#define UCR_01_CELL_VOLTAGE2_CELL25_NAME "Cell25"
#define UCR_01_CELL_VOLTAGE2_CELL26_NAME "Cell26"
#define UCR_01_CELL_VOLTAGE2_CELL27_NAME "Cell27"
#define UCR_01_CELL_VOLTAGE2_CELL28_NAME "Cell28"
#define UCR_01_CELL_VOLTAGE2_CELL29_NAME "Cell29"
#define UCR_01_CELL_VOLTAGE2_CELL30_NAME "Cell30"
#define UCR_01_CELL_VOLTAGE2_CELL31_NAME "Cell31"
#define UCR_01_CELL_VOLTAGE2_CELL32_NAME "Cell32"
#define UCR_01_CELL_VOLTAGE3_CELL33_NAME "Cell33"
#define UCR_01_CELL_VOLTAGE3_CELL34_NAME "Cell34"
#define UCR_01_CELL_VOLTAGE3_CELL35_NAME "Cell35"
#define UCR_01_CELL_VOLTAGE3_CELL36_NAME "Cell36"
#define UCR_01_CELL_VOLTAGE3_CELL37_NAME "Cell37"
#define UCR_01_CELL_VOLTAGE3_CELL38_NAME "Cell38"
#define UCR_01_CELL_VOLTAGE3_CELL39_NAME "Cell39"
#define UCR_01_CELL_VOLTAGE3_CELL40_NAME "Cell40"
#define UCR_01_CELL_VOLTAGE3_CELL41_NAME "Cell41"
#define UCR_01_CELL_VOLTAGE3_CELL42_NAME "Cell42"
#define UCR_01_CELL_VOLTAGE3_CELL43_NAME "Cell43"
#define UCR_01_CELL_VOLTAGE3_CELL44_NAME "Cell44"
#define UCR_01_CELL_VOLTAGE3_CELL45_NAME "Cell45"
#define UCR_01_CELL_VOLTAGE3_CELL46_NAME "Cell46"
#define UCR_01_CELL_VOLTAGE3_CELL47_NAME "Cell47"
#define UCR_01_CELL_VOLTAGE3_CELL48_NAME "Cell48"
#define UCR_01_CELL_VOLTAGE4_CELL49_NAME "Cell49"
#define UCR_01_CELL_VOLTAGE4_CELL50_NAME "Cell50"
#define UCR_01_CELL_VOLTAGE4_CELL51_NAME "Cell51"
#define UCR_01_CELL_VOLTAGE4_CELL52_NAME "Cell52"
#define UCR_01_CELL_VOLTAGE4_CELL53_NAME "Cell53"
#define UCR_01_CELL_VOLTAGE4_CELL54_NAME "Cell54"
#define UCR_01_CELL_VOLTAGE4_CELL55_NAME "Cell55"
#define UCR_01_CELL_VOLTAGE4_CELL56_NAME "Cell56"
#define UCR_01_CELL_VOLTAGE4_CELL57_NAME "Cell57"
#define UCR_01_CELL_VOLTAGE4_CELL58_NAME "Cell58"
#define UCR_01_CELL_VOLTAGE4_CELL59_NAME "Cell59"
#define UCR_01_CELL_VOLTAGE4_CELL60_NAME "Cell60"
#define UCR_01_CELL_VOLTAGE4_CELL61_NAME "Cell61"
#define UCR_01_CELL_VOLTAGE4_CELL62_NAME "Cell62"
#define UCR_01_CELL_VOLTAGE4_CELL63_NAME "Cell63"
#define UCR_01_CELL_VOLTAGE4_CELL64_NAME "Cell64"
#define UCR_01_CELL_VOLTAGE5_CELL65_NAME "Cell65"
#define UCR_01_CELL_VOLTAGE5_CELL66_NAME "Cell66"
#define UCR_01_CELL_VOLTAGE5_CELL67_NAME "Cell67"
#define UCR_01_CELL_VOLTAGE5_CELL68_NAME "Cell68"
#define UCR_01_CELL_VOLTAGE5_CELL69_NAME "Cell69"
#define UCR_01_CELL_VOLTAGE5_CELL70_NAME "Cell70"
#define UCR_01_CELL_VOLTAGE5_CELL71_NAME "Cell71"
#define UCR_01_CELL_VOLTAGE5_CELL72_NAME "Cell72"
#define UCR_01_CELL_VOLTAGE5_CELL73_NAME "Cell73"
#define UCR_01_CELL_VOLTAGE5_CELL74_NAME "Cell74"
#define UCR_01_CELL_VOLTAGE5_CELL75_NAME "Cell75"
#define UCR_01_CELL_VOLTAGE5_CELL76_NAME "Cell76"
#define UCR_01_CELL_VOLTAGE5_CELL77_NAME "Cell77"
#define UCR_01_CELL_VOLTAGE5_CELL78_NAME "Cell78"
#define UCR_01_CELL_VOLTAGE5_CELL79_NAME "Cell79"
#define UCR_01_CELL_VOLTAGE5_CELL80_NAME "Cell80"
#define UCR_01_CELL_VOLTAGE6_CELL81_NAME "Cell81"
#define UCR_01_CELL_VOLTAGE6_CELL82_NAME "Cell82"
#define UCR_01_CELL_VOLTAGE6_CELL83_NAME "Cell83"
#define UCR_01_CELL_VOLTAGE6_CELL84_NAME "Cell84"
#define UCR_01_CELL_VOLTAGE6_CELL85_NAME "Cell85"
#define UCR_01_CELL_VOLTAGE6_CELL86_NAME "Cell86"
#define UCR_01_CELL_VOLTAGE6_CELL87_NAME "Cell87"
#define UCR_01_CELL_VOLTAGE6_CELL88_NAME "Cell88"
#define UCR_01_CELL_VOLTAGE6_CELL89_NAME "Cell89"
#define UCR_01_CELL_VOLTAGE6_CELL90_NAME "Cell90"
#define UCR_01_CELL_VOLTAGE6_CELL91_NAME "Cell91"
#define UCR_01_CELL_VOLTAGE6_CELL92_NAME "Cell92"
#define UCR_01_CELL_VOLTAGE6_CELL93_NAME "Cell93"
#define UCR_01_CELL_VOLTAGE6_CELL94_NAME "Cell94"
#define UCR_01_CELL_VOLTAGE6_CELL95_NAME "Cell95"
#define UCR_01_CELL_VOLTAGE6_CELL96_NAME "Cell96"
#define UCR_01_CELL_VOLTAGE7_CELL97_NAME "Cell97"
#define UCR_01_CELL_VOLTAGE7_CELL98_NAME "Cell98"
#define UCR_01_CELL_VOLTAGE7_CELL99_NAME "Cell99"
#define UCR_01_CELL_VOLTAGE7_CELL101_NAME "Cell101"
#define UCR_01_CELL_VOLTAGE7_CELL102_NAME "Cell102"
#define UCR_01_CELL_VOLTAGE7_CELL103_NAME "Cell103"
#define UCR_01_CELL_VOLTAGE7_CELL104_NAME "Cell104"
#define UCR_01_CELL_VOLTAGE7_CELL105_NAME "Cell105"
#define UCR_01_CELL_VOLTAGE7_CELL106_NAME "Cell106"
#define UCR_01_CELL_VOLTAGE7_CELL107_NAME "Cell107"
#define UCR_01_CELL_VOLTAGE7_CELL108_NAME "Cell108"
#define UCR_01_CELL_VOLTAGE7_CELL109_NAME "Cell109"
#define UCR_01_CELL_VOLTAGE7_CELL110_NAME "Cell110"
#define UCR_01_CELL_VOLTAGE7_CELL111_NAME "Cell111"
#define UCR_01_CELL_VOLTAGE7_CELL112_NAME "Cell112"
#define UCR_01_CELL_VOLTAGE7_CELL113_NAME "Cell113"
#define UCR_01_CELL_VOLTAGE8_CELL114_NAME "Cell114"
#define UCR_01_CELL_VOLTAGE8_CELL115_NAME "Cell115"
#define UCR_01_CELL_VOLTAGE8_CELL116_NAME "Cell116"
#define UCR_01_CELL_VOLTAGE8_CELL117_NAME "Cell117"
#define UCR_01_CELL_VOLTAGE8_CELL118_NAME "Cell118"
#define UCR_01_CELL_VOLTAGE8_CELL119_NAME "Cell119"
#define UCR_01_CELL_VOLTAGE8_CELL120_NAME "Cell120"
#define UCR_01_CELL_VOLTAGE8_CELL121_NAME "Cell121"
#define UCR_01_CELL_VOLTAGE8_CELL122_NAME "Cell122"
#define UCR_01_CELL_VOLTAGE8_CELL123_NAME "Cell123"
#define UCR_01_CELL_VOLTAGE8_CELL124_NAME "Cell124"
#define UCR_01_CELL_VOLTAGE8_CELL125_NAME "Cell125"
#define UCR_01_CELL_VOLTAGE8_CELL126_NAME "Cell126"
#define UCR_01_CELL_VOLTAGE8_CELL127_NAME "Cell127"
#define UCR_01_CELL_VOLTAGE8_CELL128_NAME "Cell128"
#define UCR_01_CELL_VOLTAGE8_CELL129_NAME "Cell129"
#define UCR_01_THERMISTOR1_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR1_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR1_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR1_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR1_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR1_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR1_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR1_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR1_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR1_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR1_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR1_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR1_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR1_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR1_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR1_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR2_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR2_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR2_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR2_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR2_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR2_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR2_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR2_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR2_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR2_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR2_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR2_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR2_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR2_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR2_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR2_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR3_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR3_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR3_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR3_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR3_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR3_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR3_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR3_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR3_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR3_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR3_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR3_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR3_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR3_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR3_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR3_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR4_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR4_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR4_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR4_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR4_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR4_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR4_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR4_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR4_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR4_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR4_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR4_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR4_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR4_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR4_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR4_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR5_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR5_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR5_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR5_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR5_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR5_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR5_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR5_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR5_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR5_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR5_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR5_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR5_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR5_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR5_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR5_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR6_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR6_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR6_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR6_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR6_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR6_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR6_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR6_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR6_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR6_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR6_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR6_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR6_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR6_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR6_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR6_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR7_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR7_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR7_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR7_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR7_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR7_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR7_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR7_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR7_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR7_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR7_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR7_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR7_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR7_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR7_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR7_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR8_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR8_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR8_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR8_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR8_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR8_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR8_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR8_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR8_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR8_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR8_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR8_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR8_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR8_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR8_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR8_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR9_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR9_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR9_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR9_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR9_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR9_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR9_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR9_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR9_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR9_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR9_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR9_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR9_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR9_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR9_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR9_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR10_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR10_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR10_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR10_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR10_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR10_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR10_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR10_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR10_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR10_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR10_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR10_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR10_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR10_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR10_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR10_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR11_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR11_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR11_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR11_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR11_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR11_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR11_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR11_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR11_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR11_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR11_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR11_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR11_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR11_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR11_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR11_THERM16_NAME "Therm16"
#define UCR_01_THERMISTOR12_THERM1_NAME "Therm1"
#define UCR_01_THERMISTOR12_THERM2_NAME "Therm2"
#define UCR_01_THERMISTOR12_THERM3_NAME "Therm3"
#define UCR_01_THERMISTOR12_THERM4_NAME "Therm4"
#define UCR_01_THERMISTOR12_THERM5_NAME "Therm5"
#define UCR_01_THERMISTOR12_THERM6_NAME "Therm6"
#define UCR_01_THERMISTOR12_THERM7_NAME "Therm7"
#define UCR_01_THERMISTOR12_THERM8_NAME "Therm8"
#define UCR_01_THERMISTOR12_THERM9_NAME "Therm9"
#define UCR_01_THERMISTOR12_THERM10_NAME "Therm10"
#define UCR_01_THERMISTOR12_THERM11_NAME "Therm11"
#define UCR_01_THERMISTOR12_THERM12_NAME "Therm12"
#define UCR_01_THERMISTOR12_THERM13_NAME "Therm13"
#define UCR_01_THERMISTOR12_THERM14_NAME "Therm14"
#define UCR_01_THERMISTOR12_THERM15_NAME "Therm15"
#define UCR_01_THERMISTOR12_THERM16_NAME "Therm16"
#define UCR_01_PACK_VOLTAGE_PACK_VOLTAGE_NAME "PackVoltage"
#define UCR_01_TCU1_APPS1_NAME "APPS1"
#define UCR_01_TCU1_APPS2_NAME "APPS2"
#define UCR_01_TCU1_BSE_NAME "BSE"
#define UCR_01_TCU1_STATUS_NAME "Status"
#define UCR_01_TCU2_BRAKE_LIGHT_NAME "BrakeLight"
#define UCR_01_TCU2_BAMOCAR_RFE_NAME "BamocarRFE"
#define UCR_01_TCU2_BAMOCAR_FRG_NAME "BamocarFRG"
#define UCR_01_ACULV_FD_1_AMS_STATUS_NAME "AMSStatus"
#define UCR_01_ACULV_FD_1_FLD_NAME "FLD"
#define UCR_01_ACULV_FD_1_STATE_OF_CHARGE_NAME "StateOfCharge"
#define UCR_01_ACULV_FD_1_ACCUMULATOR_VOLTAGE_NAME "AccumulatorVoltage"
#define UCR_01_ACULV_FD_1_TRACTIVE_VOLTAGE_NAME "TractiveVoltage"
#define UCR_01_ACULV_FD_1_CELL_CURRENT_NAME "CellCurrent"
#define UCR_01_ACULV_FD_1_ISOLATION_MONITORING_NAME "IsolationMonitoring"
#define UCR_01_ACULV_FD_1_ISOLATION_MONITORING1_NAME "IsolationMonitoring1"
#define UCR_01_ACULV_FD_2_FAN_SET_POINT_NAME "FanSetPoint"
#define UCR_01_ACULV_FD_2_RPM_NAME "RPM"
#define UCR_01_ACULV1_CHARGE_STATUS1_NAME "ChargeStatus1"
#define UCR_01_ACULV1_CHARGE_STATUS2_NAME "ChargeStatus2"
#define UCR_01_ACULV2_CHARGE_REQUEST_NAME "ChargeRequest"
#define UCR_01_PDM1_COMPOUND_ID_NAME "CompoundID"
#define UCR_01_PDM1_PDM_INT_TEMPERATURE_NAME "PDMIntTemperature"
#define UCR_01_PDM1_PDM_BATT_VOLTAGE_NAME "PDMBattVoltage"
#define UCR_01_PDM1_GLOBAL_ERROR_FLAG_NAME "GlobalErrorFlag"
#define UCR_01_PDM1_TOTAL_CURRENT_NAME "TotalCurrent"
#define UCR_01_PDM1_INTERNAL_RAIL_VOLTAGE_NAME "InternalRailVoltage"
#define UCR_01_PDM1_RESET_SOURCE_NAME "ResetSource"
#define UCR_01_BAMOCAR_TX_DATA_REGID_NAME "REGID"
#define UCR_01_BAMOCAR_TX_DATA_DATA_NAME "Data"
#define UCR_01_INS_GPS_GNSS_WEEK_NAME "gnss_week"
#define UCR_01_INS_GPS_GNSS_SECONDS_NAME "gnss_seconds"
#define UCR_01_INS_GPS_GNSS_LAT_NAME "gnss_lat"
#define UCR_01_INS_GPS_GNSS_LONG_NAME "gnss_long"
#define UCR_01_INS_GPS_GNSS_HEIGHT_NAME "gnss_height"
#define UCR_01_INS_IMU_NORTH_VEL_NAME "north_vel"
#define UCR_01_INS_IMU_EAST_VEL_NAME "east_vel"
#define UCR_01_INS_IMU_UP_VEL_NAME "up_vel"
#define UCR_01_INS_IMU_ROLL_NAME "roll"
#define UCR_01_INS_IMU_PITCH_NAME "pitch"
#define UCR_01_INS_IMU_AZIMUTH_NAME "azimuth"
#define UCR_01_INS_IMU_STATUS_NAME "status"
#define UCR_01_BAMO_CAR_RE_TRANSMIT_MOTOR_TEMP_RAW_NAME "MotorTempRaw"
#define UCR_01_BAMO_CAR_RE_TRANSMIT_CONTROLLER_TEMP_RAW_NAME "ControllerTempRaw"
#define UCR_01_PDM_CURRENT_ACCUMULATOR_CURRENT_NAME "AccumulatorCurrent"
#define UCR_01_PDM_CURRENT_TCU_CURRENT_NAME "TCUCurrent"
#define UCR_01_PDM_CURRENT_BAMOCAR_CURRENT_NAME "BamocarCurrent"
#define UCR_01_PDM_CURRENT_PUMPS_CURRENT_NAME "PumpsCurrent"
#define UCR_01_PDM_CURRENT_TSAL_CURRENT_NAME "TSALCurrent"
#define UCR_01_PDM_CURRENT_DAQ_CURRENT_NAME "DAQCurrent"
#define UCR_01_PDM_CURRENT_DISPLAY_KVASER_CURRENT_NAME "DisplayKvaserCurrent"
#define UCR_01_PDM_CURRENT_SHUTDOWN_RESET_CURRENT_NAME "ShutdownResetCurrent"
#define UCR_01_PDM_RE_TRANSMIT_PDM_INT_TEMPERATURE_NAME "PDMIntTemperature"
#define UCR_01_PDM_RE_TRANSMIT_PDM_BATT_VOLTAGE_NAME "PDMBattVoltage"
#define UCR_01_PDM_RE_TRANSMIT_GLOBAL_ERROR_FLAG_NAME "GlobalErrorFlag"
#define UCR_01_PDM_RE_TRANSMIT_TOTAL_CURRENT_NAME "TotalCurrent"
#define UCR_01_PDM_RE_TRANSMIT_INTERNAL_RAIL_VOLTAGE_NAME "InternalRailVoltage"
#define UCR_01_PDM_RE_TRANSMIT_RESET_SOURCE_NAME "ResetSource"
#define UCR_01_PACK_POWER_PACK_CURRENT_NAME "PackCurrent"
#define UCR_01_PACK_POWER_PACK_VOLTAGE_NAME "PackVoltage"
#define UCR_01_PACK_POWER_PACK_POWER_NAME "PackPower"
#define UCR_01_BAMO_CAR_CONVERTED_MOTOR_TEMP_NAME "MotorTemp"
#define UCR_01_BAMO_CAR_CONVERTED_CONTROLLER_TEMP_NAME "ControllerTemp"
#define UCR_01_LAP_INFO_TIME_MS_NAME "TimeMS"
#define UCR_01_LAP_INFO_LAP_NUM_NAME "LapNum"
#define UCR_01_POWER_LIMIT_INFO1_MOTOR_RPM_NAME "MotorRPM"
#define UCR_01_POWER_LIMIT_INFO1_OUTPUT_CURRENT_NAME "OutputCurrent"
#define UCR_01_POWER_LIMIT_INFO1_OUTPUT_CURRENT_LIMIT_NAME "OutputCurrentLimit"
#define UCR_01_POWER_LIMIT_INFO1_APPS1_NAME "APPS1"
#define UCR_01_POWER_LIMIT_INFO2_PACK_CURRENT_NAME "PackCurrent"
#define UCR_01_POWER_LIMIT_INFO2_PACK_POWER_NAME "PackPower"

/**
 * Signals in message FrontAnalog.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_front_analog_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t left_rad;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t right_rad;

    /**
     * Range: -
     * Scale: 0.018315018315
     * Offset: 0
     */
    uint16_t front_right_pot;

    /**
     * Range: -
     * Scale: 0.018315018315
     * Offset: 0
     */
    uint16_t front_left_pot;

    /**
     * Range: -
     * Scale: 0.018315018315
     * Offset: 0
     */
    uint16_t rear_right_pot;

    /**
     * Range: -
     * Scale: 0.018315018315
     * Offset: 0
     */
    uint16_t rear_left_pot;

    /**
     * Range: -
     * Scale: 0.018315018315
     * Offset: 0
     */
    uint16_t steering_angle;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog8;
};

/**
 * Signals in message RearAnalog.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_rear_analog_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t analog8;
};

/**
 * Signals in message FrontAero.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_front_aero_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t temperature1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t temperature2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t temperature3;
};

/**
 * Signals in message RearAero.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_rear_aero_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t pressure3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t temperature1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t temperature2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t temperature3;
};

/**
 * Signals in message EncoderPositions.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_encoder_positions_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder4;
};

/**
 * Signals in message FrontStrainGauges1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_front_strain_gauges1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t flpr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t flru;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t flfl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t flrl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t flfu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t fls;
};

/**
 * Signals in message FrontStrainGauges2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_front_strain_gauges2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t frs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t frfu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t frfl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t frrl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t frru;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t frpr;
};

/**
 * Signals in message RearStrainGauges1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_rear_strain_gauges1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t rrt;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rrrl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rrru;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rrfl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rrfu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rrpr;
};

/**
 * Signals in message RearStrainGauges2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_rear_strain_gauges2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rlfl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rlfu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rlpr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rlru;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rlrl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t rlt;
};

/**
 * Signals in message GPSBestPos.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_gps_best_pos_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double latitude;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double longitude;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double altitude;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double std_latitude;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double std_longitude;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double std_altitude;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t gps_status;
};

/**
 * Signals in message FrontFrequency.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_front_frequency_t {
    /**
     * Range: -
     * Scale: 0.2127905424
     * Offset: 0
     */
    float rear_right;

    /**
     * Range: -
     * Scale: 0.042558108
     * Offset: 0
     */
    float front_right;

    /**
     * Range: -
     * Scale: 0.2127905424
     * Offset: 0
     */
    float rear_left;

    /**
     * Range: -
     * Scale: 0.042558108
     * Offset: 0
     */
    float front_left;
};

/**
 * Signals in message RearFrequency.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_rear_frequency_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float freq1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float freq2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float freq3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float freq4;
};

/**
 * Signals in message BamocarRxData.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_bamocar_rx_data_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regid;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte5;
};

/**
 * Signals in message CellVoltage1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell16;
};

/**
 * Signals in message CellVoltage2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell17;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell18;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell19;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell20;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell21;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell22;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell23;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell24;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell25;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell26;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell27;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell28;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell29;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell30;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell31;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell32;
};

/**
 * Signals in message CellVoltage3.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell33;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell34;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell35;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell36;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell37;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell38;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell39;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell40;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell41;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell42;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell43;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell44;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell45;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell46;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell47;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell48;
};

/**
 * Signals in message CellVoltage4.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell49;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell50;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell51;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell52;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell53;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell54;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell55;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell56;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell57;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell58;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell59;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell60;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell61;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell62;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell63;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell64;
};

/**
 * Signals in message CellVoltage5.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage5_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell65;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell66;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell67;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell68;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell69;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell70;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell71;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell72;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell73;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell74;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell75;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell76;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell77;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell78;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell79;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell80;
};

/**
 * Signals in message CellVoltage6.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage6_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell81;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell82;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell83;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell84;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell85;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell86;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell87;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell88;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell89;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell90;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell91;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell92;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell93;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell94;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell95;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell96;
};

/**
 * Signals in message CellVoltage7.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage7_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell97;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell98;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell99;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell101;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell102;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell103;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell104;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell105;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell106;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell107;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell108;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell109;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell110;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell111;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell112;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell113;
};

/**
 * Signals in message CellVoltage8.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_cell_voltage8_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell114;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell115;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell116;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell117;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell118;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell119;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell120;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell121;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell122;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell123;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell124;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell125;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell126;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell127;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell128;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int32_t cell129;
};

/**
 * Signals in message Thermistor1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor3.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor4.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor4_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor5.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor5_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor6.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor6_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor7.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor7_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor8.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor8_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor9.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor9_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor10.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor10_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor11.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor11_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message Thermistor12.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_thermistor12_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm6;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm7;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm8;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm9;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm10;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm11;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm12;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm13;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm14;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm15;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float therm16;
};

/**
 * Signals in message PackVoltage.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_pack_voltage_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pack_voltage;
};

/**
 * Signals in message TCU1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_tcu1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float apps1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float apps2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float bse;

    /**
     * RTD Button, Light, Status
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message TCU2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_tcu2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_light;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bamocar_rfe;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bamocar_frg;
};

/**
 * Signals in message ACULV_FD_1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_aculv_fd_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t fld;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float state_of_charge;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float accumulator_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float tractive_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float cell_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t isolation_monitoring;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float isolation_monitoring1;
};

/**
 * Signals in message ACULV_FD_2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_aculv_fd_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float fan_set_point;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float rpm;
};

/**
 * Signals in message ACULV1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_aculv1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float charge_status1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float charge_status2;
};

/**
 * Signals in message ACULV2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_aculv2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t charge_request;
};

/**
 * Signals in message PDM1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_pdm1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t compound_id;

    /**
     * Range: 0..125 (0..125 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pdm_int_temperature;

    /**
     * Range: 0.0..254.93421052631578 (0..31 -)
     * Scale: 0.1216
     * Offset: 0
     */
    double pdm_batt_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t global_error_flag;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_current;

    /**
     * Range: 0.0..254.95934959349594 (0..15.68 -)
     * Scale: 0.0615
     * Offset: 0
     */
    double internal_rail_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t reset_source;
};

/**
 * Signals in message BamocarTxData.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_bamocar_tx_data_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t regid;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t data;
};

/**
 * Signals in message INS_GPS.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_ins_gps_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t gnss_week;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double gnss_seconds;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double gnss_lat;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double gnss_long;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double gnss_height;
};

/**
 * Signals in message INS_IMU.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_ins_imu_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double north_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double east_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double up_vel;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double roll;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double pitch;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    double azimuth;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;
};

/**
 * Signals in message BamoCarReTransmit.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_bamo_car_re_transmit_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_temp_raw;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t controller_temp_raw;
};

/**
 * Signals in message PDMCurrent.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_pdm_current_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t accumulator_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tcu_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bamocar_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pumps_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t daq_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t display_kvaser_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t shutdown_reset_current;
};

/**
 * Signals in message PDMReTransmit.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_pdm_re_transmit_t {
    /**
     * Range: 0..125 (0..125 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pdm_int_temperature;

    /**
     * Range: 0..255 (0..31 -)
     * Scale: 0.1216
     * Offset: 0
     */
    int8_t pdm_batt_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t global_error_flag;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t total_current;

    /**
     * Range: 0..255 (0..15.68 -)
     * Scale: 0.0615
     * Offset: 0
     */
    uint8_t internal_rail_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t reset_source;
};

/**
 * Signals in message PackPower.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_pack_power_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pack_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pack_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pack_power;
};

/**
 * Signals in message BamoCarConverted.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_bamo_car_converted_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float motor_temp;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float controller_temp;
};

/**
 * Signals in message LapInfo.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_lap_info_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_ms;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_num;
};

/**
 * Signals in message Power_Limit_Info1.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_power_limit_info1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_rpm;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t output_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t output_current_limit;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps1;
};

/**
 * Signals in message Power_Limit_Info2.
 *
 * All signal values are as on the CAN bus.
 */
struct ucr_01_power_limit_info2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pack_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float pack_power;
};

/**
 * Pack message FrontAnalog.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_front_analog_pack(
    uint8_t *dst_p,
    const struct ucr_01_front_analog_t *src_p,
    size_t size);

/**
 * Unpack message FrontAnalog.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_front_analog_unpack(
    struct ucr_01_front_analog_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FrontAnalog.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_front_analog_init(struct ucr_01_front_analog_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_left_rad_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_left_rad_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_left_rad_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_right_rad_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_right_rad_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_right_rad_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_front_right_pot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_front_right_pot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_front_right_pot_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_front_left_pot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_front_left_pot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_front_left_pot_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_rear_right_pot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_rear_right_pot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_rear_right_pot_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_rear_left_pot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_rear_left_pot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_rear_left_pot_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_steering_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_steering_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_steering_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_front_analog_analog8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_analog_analog8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_analog_analog8_is_in_range(uint16_t value);

/**
 * Pack message RearAnalog.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_rear_analog_pack(
    uint8_t *dst_p,
    const struct ucr_01_rear_analog_t *src_p,
    size_t size);

/**
 * Unpack message RearAnalog.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_rear_analog_unpack(
    struct ucr_01_rear_analog_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RearAnalog.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_rear_analog_init(struct ucr_01_rear_analog_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_rear_analog_analog8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_analog_analog8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_analog_analog8_is_in_range(uint16_t value);

/**
 * Pack message FrontAero.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_front_aero_pack(
    uint8_t *dst_p,
    const struct ucr_01_front_aero_t *src_p,
    size_t size);

/**
 * Unpack message FrontAero.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_front_aero_unpack(
    struct ucr_01_front_aero_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FrontAero.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_front_aero_init(struct ucr_01_front_aero_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_front_aero_pressure1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_aero_pressure1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_aero_pressure1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_front_aero_pressure2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_aero_pressure2_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_aero_pressure2_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_front_aero_pressure3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_aero_pressure3_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_aero_pressure3_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_front_aero_temperature1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_aero_temperature1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_aero_temperature1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_front_aero_temperature2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_aero_temperature2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_aero_temperature2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_front_aero_temperature3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_aero_temperature3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_aero_temperature3_is_in_range(int16_t value);

/**
 * Pack message RearAero.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_rear_aero_pack(
    uint8_t *dst_p,
    const struct ucr_01_rear_aero_t *src_p,
    size_t size);

/**
 * Unpack message RearAero.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_rear_aero_unpack(
    struct ucr_01_rear_aero_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RearAero.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_rear_aero_init(struct ucr_01_rear_aero_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_rear_aero_pressure1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_aero_pressure1_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_aero_pressure1_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_rear_aero_pressure2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_aero_pressure2_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_aero_pressure2_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_rear_aero_pressure3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_aero_pressure3_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_aero_pressure3_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_rear_aero_temperature1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_aero_temperature1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_aero_temperature1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_rear_aero_temperature2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_aero_temperature2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_aero_temperature2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_rear_aero_temperature3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_aero_temperature3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_aero_temperature3_is_in_range(int16_t value);

/**
 * Pack message EncoderPositions.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_encoder_positions_pack(
    uint8_t *dst_p,
    const struct ucr_01_encoder_positions_t *src_p,
    size_t size);

/**
 * Unpack message EncoderPositions.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_encoder_positions_unpack(
    struct ucr_01_encoder_positions_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from EncoderPositions.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_encoder_positions_init(struct ucr_01_encoder_positions_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_encoder_positions_encoder1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_encoder_positions_encoder1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_encoder_positions_encoder1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_encoder_positions_encoder2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_encoder_positions_encoder2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_encoder_positions_encoder2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_encoder_positions_encoder3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_encoder_positions_encoder3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_encoder_positions_encoder3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_encoder_positions_encoder4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_encoder_positions_encoder4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_encoder_positions_encoder4_is_in_range(uint8_t value);

/**
 * Pack message FrontStrainGauges1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_front_strain_gauges1_pack(
    uint8_t *dst_p,
    const struct ucr_01_front_strain_gauges1_t *src_p,
    size_t size);

/**
 * Unpack message FrontStrainGauges1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_front_strain_gauges1_unpack(
    struct ucr_01_front_strain_gauges1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FrontStrainGauges1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_front_strain_gauges1_init(struct ucr_01_front_strain_gauges1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges1_flpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges1_flpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges1_flpr_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges1_flru_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges1_flru_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges1_flru_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges1_flfl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges1_flfl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges1_flfl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges1_flrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges1_flrl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges1_flrl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges1_flfu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges1_flfu_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges1_flfu_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges1_fls_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges1_fls_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges1_fls_is_in_range(uint32_t value);

/**
 * Pack message FrontStrainGauges2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_front_strain_gauges2_pack(
    uint8_t *dst_p,
    const struct ucr_01_front_strain_gauges2_t *src_p,
    size_t size);

/**
 * Unpack message FrontStrainGauges2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_front_strain_gauges2_unpack(
    struct ucr_01_front_strain_gauges2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FrontStrainGauges2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_front_strain_gauges2_init(struct ucr_01_front_strain_gauges2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges2_frs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges2_frs_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges2_frs_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges2_frfu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges2_frfu_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges2_frfu_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges2_frfl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges2_frfl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges2_frfl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges2_frrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges2_frrl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges2_frrl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges2_frru_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges2_frru_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges2_frru_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_front_strain_gauges2_frpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_strain_gauges2_frpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_strain_gauges2_frpr_is_in_range(uint32_t value);

/**
 * Pack message RearStrainGauges1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_rear_strain_gauges1_pack(
    uint8_t *dst_p,
    const struct ucr_01_rear_strain_gauges1_t *src_p,
    size_t size);

/**
 * Unpack message RearStrainGauges1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_rear_strain_gauges1_unpack(
    struct ucr_01_rear_strain_gauges1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RearStrainGauges1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_rear_strain_gauges1_init(struct ucr_01_rear_strain_gauges1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_rear_strain_gauges1_rrt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges1_rrt_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges1_rrt_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges1_rrrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges1_rrrl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges1_rrrl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges1_rrru_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges1_rrru_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges1_rrru_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges1_rrfl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges1_rrfl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges1_rrfl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges1_rrfu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges1_rrfu_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges1_rrfu_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges1_rrpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges1_rrpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges1_rrpr_is_in_range(uint32_t value);

/**
 * Pack message RearStrainGauges2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_rear_strain_gauges2_pack(
    uint8_t *dst_p,
    const struct ucr_01_rear_strain_gauges2_t *src_p,
    size_t size);

/**
 * Unpack message RearStrainGauges2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_rear_strain_gauges2_unpack(
    struct ucr_01_rear_strain_gauges2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RearStrainGauges2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_rear_strain_gauges2_init(struct ucr_01_rear_strain_gauges2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges2_rlfl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges2_rlfl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges2_rlfl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges2_rlfu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges2_rlfu_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges2_rlfu_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges2_rlpr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges2_rlpr_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges2_rlpr_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges2_rlru_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges2_rlru_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges2_rlru_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges2_rlrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges2_rlrl_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges2_rlrl_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_rear_strain_gauges2_rlt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_strain_gauges2_rlt_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_strain_gauges2_rlt_is_in_range(uint32_t value);

/**
 * Pack message GPSBestPos.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_gps_best_pos_pack(
    uint8_t *dst_p,
    const struct ucr_01_gps_best_pos_t *src_p,
    size_t size);

/**
 * Unpack message GPSBestPos.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_gps_best_pos_unpack(
    struct ucr_01_gps_best_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from GPSBestPos.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_gps_best_pos_init(struct ucr_01_gps_best_pos_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_gps_best_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_latitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_latitude_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_gps_best_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_longitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_longitude_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_gps_best_pos_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_altitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_altitude_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_gps_best_pos_std_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_std_latitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_std_latitude_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_gps_best_pos_std_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_std_longitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_std_longitude_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_gps_best_pos_std_altitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_std_altitude_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_std_altitude_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_gps_best_pos_gps_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_gps_best_pos_gps_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_gps_best_pos_gps_status_is_in_range(uint8_t value);

/**
 * Pack message FrontFrequency.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_front_frequency_pack(
    uint8_t *dst_p,
    const struct ucr_01_front_frequency_t *src_p,
    size_t size);

/**
 * Unpack message FrontFrequency.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_front_frequency_unpack(
    struct ucr_01_front_frequency_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from FrontFrequency.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_front_frequency_init(struct ucr_01_front_frequency_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_front_frequency_rear_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_frequency_rear_right_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_frequency_rear_right_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_front_frequency_front_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_frequency_front_right_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_frequency_front_right_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_front_frequency_rear_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_frequency_rear_left_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_frequency_rear_left_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_front_frequency_front_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_front_frequency_front_left_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_front_frequency_front_left_is_in_range(float value);

/**
 * Pack message RearFrequency.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_rear_frequency_pack(
    uint8_t *dst_p,
    const struct ucr_01_rear_frequency_t *src_p,
    size_t size);

/**
 * Unpack message RearFrequency.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_rear_frequency_unpack(
    struct ucr_01_rear_frequency_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from RearFrequency.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_rear_frequency_init(struct ucr_01_rear_frequency_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_rear_frequency_freq1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_frequency_freq1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_frequency_freq1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_rear_frequency_freq2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_frequency_freq2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_frequency_freq2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_rear_frequency_freq3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_frequency_freq3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_frequency_freq3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_rear_frequency_freq4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_rear_frequency_freq4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_rear_frequency_freq4_is_in_range(float value);

/**
 * Pack message BamocarRxData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_bamocar_rx_data_pack(
    uint8_t *dst_p,
    const struct ucr_01_bamocar_rx_data_t *src_p,
    size_t size);

/**
 * Unpack message BamocarRxData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_bamocar_rx_data_unpack(
    struct ucr_01_bamocar_rx_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BamocarRxData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_bamocar_rx_data_init(struct ucr_01_bamocar_rx_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_rx_data_regid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_rx_data_regid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_rx_data_regid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_rx_data_byte1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_rx_data_byte1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_rx_data_byte1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_rx_data_byte2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_rx_data_byte2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_rx_data_byte2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_rx_data_byte3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_rx_data_byte3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_rx_data_byte3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_rx_data_byte4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_rx_data_byte4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_rx_data_byte4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_rx_data_byte5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_rx_data_byte5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_rx_data_byte5_is_in_range(uint8_t value);

/**
 * Pack message CellVoltage1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage1_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage1_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage1_unpack(
    struct ucr_01_cell_voltage1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage1_init(struct ucr_01_cell_voltage1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage1_cell16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage1_cell16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage1_cell16_is_in_range(float value);

/**
 * Pack message CellVoltage2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage2_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage2_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage2_unpack(
    struct ucr_01_cell_voltage2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage2_init(struct ucr_01_cell_voltage2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell17_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell17_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell17_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell18_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell18_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell18_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell19_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell19_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell19_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell20_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell20_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell20_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell21_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell21_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell21_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell22_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell22_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell22_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell23_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell23_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell23_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell24_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell24_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell24_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell25_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell25_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell25_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell26_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell26_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell26_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell27_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell27_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell27_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell28_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell28_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell28_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell29_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell29_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell29_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell30_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell30_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell30_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell31_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell31_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell31_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage2_cell32_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage2_cell32_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage2_cell32_is_in_range(float value);

/**
 * Pack message CellVoltage3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage3_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage3_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage3_unpack(
    struct ucr_01_cell_voltage3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage3_init(struct ucr_01_cell_voltage3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell33_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell33_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell33_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell34_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell34_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell34_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell35_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell35_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell35_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell36_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell36_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell36_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell37_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell37_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell37_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell38_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell38_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell38_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell39_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell39_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell39_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell40_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell40_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell40_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell41_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell41_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell41_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell42_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell42_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell42_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell43_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell43_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell43_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell44_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell44_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell44_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell45_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell45_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell45_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell46_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell46_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell46_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell47_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell47_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell47_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage3_cell48_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage3_cell48_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage3_cell48_is_in_range(float value);

/**
 * Pack message CellVoltage4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage4_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage4_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage4_unpack(
    struct ucr_01_cell_voltage4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage4_init(struct ucr_01_cell_voltage4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell49_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell49_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell49_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell50_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell50_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell50_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell51_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell51_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell51_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell52_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell52_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell52_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell53_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell53_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell53_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell54_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell54_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell54_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell55_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell55_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell55_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell56_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell56_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell56_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell57_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell57_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell57_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell58_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell58_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell58_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell59_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell59_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell59_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell60_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell60_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell60_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell61_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell61_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell61_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell62_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell62_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell62_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell63_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell63_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell63_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage4_cell64_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage4_cell64_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage4_cell64_is_in_range(float value);

/**
 * Pack message CellVoltage5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage5_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage5_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage5_unpack(
    struct ucr_01_cell_voltage5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage5_init(struct ucr_01_cell_voltage5_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell65_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell65_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell65_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell66_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell66_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell66_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell67_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell67_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell67_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell68_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell68_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell68_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell69_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell69_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell69_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell70_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell70_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell70_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell71_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell71_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell71_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell72_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell72_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell72_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell73_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell73_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell73_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell74_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell74_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell74_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell75_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell75_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell75_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell76_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell76_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell76_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell77_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell77_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell77_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell78_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell78_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell78_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell79_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell79_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell79_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage5_cell80_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage5_cell80_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage5_cell80_is_in_range(float value);

/**
 * Pack message CellVoltage6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage6_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage6_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage6_unpack(
    struct ucr_01_cell_voltage6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage6_init(struct ucr_01_cell_voltage6_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell81_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell81_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell81_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell82_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell82_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell82_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell83_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell83_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell83_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell84_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell84_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell84_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell85_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell85_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell85_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell86_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell86_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell86_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell87_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell87_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell87_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell88_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell88_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell88_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell89_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell89_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell89_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell90_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell90_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell90_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell91_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell91_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell91_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell92_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell92_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell92_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell93_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell93_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell93_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell94_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell94_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell94_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell95_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell95_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell95_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage6_cell96_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage6_cell96_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage6_cell96_is_in_range(float value);

/**
 * Pack message CellVoltage7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage7_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage7_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage7_unpack(
    struct ucr_01_cell_voltage7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage7.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage7_init(struct ucr_01_cell_voltage7_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell97_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell97_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell97_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell98_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell98_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell98_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell99_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell99_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell99_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell101_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell101_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell101_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell102_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell102_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell102_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell103_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell103_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell103_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell104_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell104_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell104_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell105_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell105_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell105_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell106_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell106_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell106_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell107_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell107_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell107_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell108_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell108_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell108_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell109_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell109_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell109_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell110_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell110_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell110_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell111_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell111_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell111_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell112_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell112_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell112_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage7_cell113_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage7_cell113_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage7_cell113_is_in_range(float value);

/**
 * Pack message CellVoltage8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_cell_voltage8_pack(
    uint8_t *dst_p,
    const struct ucr_01_cell_voltage8_t *src_p,
    size_t size);

/**
 * Unpack message CellVoltage8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_cell_voltage8_unpack(
    struct ucr_01_cell_voltage8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from CellVoltage8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_cell_voltage8_init(struct ucr_01_cell_voltage8_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell114_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell114_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell114_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell115_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell115_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell115_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell116_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell116_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell116_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell117_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell117_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell117_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell118_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell118_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell118_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell119_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell119_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell119_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell120_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell120_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell120_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell121_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell121_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell121_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell122_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell122_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell122_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell123_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell123_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell123_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell124_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell124_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell124_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell125_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell125_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell125_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell126_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell126_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell126_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell127_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell127_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell127_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_cell_voltage8_cell128_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell128_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell128_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t ucr_01_cell_voltage8_cell129_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_cell_voltage8_cell129_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_cell_voltage8_cell129_is_in_range(int32_t value);

/**
 * Pack message Thermistor1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor1_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor1_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor1_unpack(
    struct ucr_01_thermistor1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor1_init(struct ucr_01_thermistor1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor1_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor1_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor1_therm16_is_in_range(float value);

/**
 * Pack message Thermistor2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor2_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor2_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor2_unpack(
    struct ucr_01_thermistor2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor2_init(struct ucr_01_thermistor2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor2_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor2_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor2_therm16_is_in_range(float value);

/**
 * Pack message Thermistor3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor3_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor3_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor3_unpack(
    struct ucr_01_thermistor3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor3.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor3_init(struct ucr_01_thermistor3_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor3_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor3_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor3_therm16_is_in_range(float value);

/**
 * Pack message Thermistor4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor4_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor4_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor4_unpack(
    struct ucr_01_thermistor4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor4.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor4_init(struct ucr_01_thermistor4_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor4_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor4_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor4_therm16_is_in_range(float value);

/**
 * Pack message Thermistor5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor5_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor5_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor5_unpack(
    struct ucr_01_thermistor5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor5.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor5_init(struct ucr_01_thermistor5_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor5_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor5_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor5_therm16_is_in_range(float value);

/**
 * Pack message Thermistor6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor6_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor6_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor6_unpack(
    struct ucr_01_thermistor6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor6.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor6_init(struct ucr_01_thermistor6_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor6_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor6_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor6_therm16_is_in_range(float value);

/**
 * Pack message Thermistor7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor7_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor7_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor7_unpack(
    struct ucr_01_thermistor7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor7.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor7_init(struct ucr_01_thermistor7_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor7_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor7_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor7_therm16_is_in_range(float value);

/**
 * Pack message Thermistor8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor8_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor8_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor8_unpack(
    struct ucr_01_thermistor8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor8.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor8_init(struct ucr_01_thermistor8_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor8_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor8_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor8_therm16_is_in_range(float value);

/**
 * Pack message Thermistor9.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor9_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor9_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor9.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor9_unpack(
    struct ucr_01_thermistor9_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor9.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor9_init(struct ucr_01_thermistor9_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor9_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor9_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor9_therm16_is_in_range(float value);

/**
 * Pack message Thermistor10.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor10_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor10_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor10.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor10_unpack(
    struct ucr_01_thermistor10_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor10.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor10_init(struct ucr_01_thermistor10_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor10_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor10_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor10_therm16_is_in_range(float value);

/**
 * Pack message Thermistor11.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor11_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor11_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor11.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor11_unpack(
    struct ucr_01_thermistor11_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor11.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor11_init(struct ucr_01_thermistor11_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor11_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor11_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor11_therm16_is_in_range(float value);

/**
 * Pack message Thermistor12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_thermistor12_pack(
    uint8_t *dst_p,
    const struct ucr_01_thermistor12_t *src_p,
    size_t size);

/**
 * Unpack message Thermistor12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_thermistor12_unpack(
    struct ucr_01_thermistor12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Thermistor12.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_thermistor12_init(struct ucr_01_thermistor12_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm3_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm3_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm4_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm4_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm5_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm5_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm6_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm6_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm7_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm7_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm8_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm8_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm9_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm9_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm10_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm10_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm11_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm11_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm12_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm12_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm13_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm13_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm14_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm14_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm15_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm15_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_thermistor12_therm16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_thermistor12_therm16_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_thermistor12_therm16_is_in_range(float value);

/**
 * Pack message PackVoltage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_pack_voltage_pack(
    uint8_t *dst_p,
    const struct ucr_01_pack_voltage_t *src_p,
    size_t size);

/**
 * Unpack message PackVoltage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_pack_voltage_unpack(
    struct ucr_01_pack_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PackVoltage.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_pack_voltage_init(struct ucr_01_pack_voltage_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_pack_voltage_pack_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pack_voltage_pack_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pack_voltage_pack_voltage_is_in_range(float value);

/**
 * Pack message TCU1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_tcu1_pack(
    uint8_t *dst_p,
    const struct ucr_01_tcu1_t *src_p,
    size_t size);

/**
 * Unpack message TCU1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_tcu1_unpack(
    struct ucr_01_tcu1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TCU1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_tcu1_init(struct ucr_01_tcu1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_tcu1_apps1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu1_apps1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu1_apps1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_tcu1_apps2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu1_apps2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu1_apps2_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_tcu1_bse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu1_bse_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu1_bse_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_tcu1_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu1_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu1_status_is_in_range(uint8_t value);

/**
 * Pack message TCU2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_tcu2_pack(
    uint8_t *dst_p,
    const struct ucr_01_tcu2_t *src_p,
    size_t size);

/**
 * Unpack message TCU2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_tcu2_unpack(
    struct ucr_01_tcu2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TCU2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_tcu2_init(struct ucr_01_tcu2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_tcu2_brake_light_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu2_brake_light_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu2_brake_light_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_tcu2_bamocar_rfe_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu2_bamocar_rfe_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu2_bamocar_rfe_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_tcu2_bamocar_frg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_tcu2_bamocar_frg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_tcu2_bamocar_frg_is_in_range(uint8_t value);

/**
 * Pack message ACULV_FD_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_aculv_fd_1_pack(
    uint8_t *dst_p,
    const struct ucr_01_aculv_fd_1_t *src_p,
    size_t size);

/**
 * Unpack message ACULV_FD_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_aculv_fd_1_unpack(
    struct ucr_01_aculv_fd_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACULV_FD_1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_aculv_fd_1_init(struct ucr_01_aculv_fd_1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_aculv_fd_1_ams_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_ams_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_ams_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_aculv_fd_1_fld_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_fld_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_fld_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_1_state_of_charge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_state_of_charge_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_state_of_charge_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_1_accumulator_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_accumulator_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_accumulator_voltage_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_1_tractive_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_tractive_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_tractive_voltage_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_1_cell_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_cell_current_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_cell_current_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_aculv_fd_1_isolation_monitoring_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_isolation_monitoring_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_isolation_monitoring_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_1_isolation_monitoring1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_1_isolation_monitoring1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_1_isolation_monitoring1_is_in_range(float value);

/**
 * Pack message ACULV_FD_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_aculv_fd_2_pack(
    uint8_t *dst_p,
    const struct ucr_01_aculv_fd_2_t *src_p,
    size_t size);

/**
 * Unpack message ACULV_FD_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_aculv_fd_2_unpack(
    struct ucr_01_aculv_fd_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACULV_FD_2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_aculv_fd_2_init(struct ucr_01_aculv_fd_2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_2_fan_set_point_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_2_fan_set_point_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_2_fan_set_point_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv_fd_2_rpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv_fd_2_rpm_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv_fd_2_rpm_is_in_range(float value);

/**
 * Pack message ACULV1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_aculv1_pack(
    uint8_t *dst_p,
    const struct ucr_01_aculv1_t *src_p,
    size_t size);

/**
 * Unpack message ACULV1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_aculv1_unpack(
    struct ucr_01_aculv1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACULV1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_aculv1_init(struct ucr_01_aculv1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv1_charge_status1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv1_charge_status1_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv1_charge_status1_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_aculv1_charge_status2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv1_charge_status2_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv1_charge_status2_is_in_range(float value);

/**
 * Pack message ACULV2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_aculv2_pack(
    uint8_t *dst_p,
    const struct ucr_01_aculv2_t *src_p,
    size_t size);

/**
 * Unpack message ACULV2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_aculv2_unpack(
    struct ucr_01_aculv2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from ACULV2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_aculv2_init(struct ucr_01_aculv2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_aculv2_charge_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_aculv2_charge_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_aculv2_charge_request_is_in_range(uint8_t value);

/**
 * Pack message PDM1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_pdm1_pack(
    uint8_t *dst_p,
    const struct ucr_01_pdm1_t *src_p,
    size_t size);

/**
 * Unpack message PDM1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_pdm1_unpack(
    struct ucr_01_pdm1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PDM1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_pdm1_init(struct ucr_01_pdm1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm1_compound_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_compound_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_compound_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm1_pdm_int_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_pdm_int_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_pdm_int_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_pdm1_pdm_batt_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_pdm_batt_voltage_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_pdm_batt_voltage_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm1_global_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_global_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_global_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm1_total_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_total_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_total_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_pdm1_internal_rail_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_internal_rail_voltage_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_internal_rail_voltage_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm1_reset_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm1_reset_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm1_reset_source_is_in_range(uint8_t value);

/**
 * Pack message BamocarTxData.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_bamocar_tx_data_pack(
    uint8_t *dst_p,
    const struct ucr_01_bamocar_tx_data_t *src_p,
    size_t size);

/**
 * Unpack message BamocarTxData.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_bamocar_tx_data_unpack(
    struct ucr_01_bamocar_tx_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BamocarTxData.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_bamocar_tx_data_init(struct ucr_01_bamocar_tx_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_bamocar_tx_data_regid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_tx_data_regid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_tx_data_regid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t ucr_01_bamocar_tx_data_data_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamocar_tx_data_data_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamocar_tx_data_data_is_in_range(uint64_t value);

/**
 * Pack message INS_GPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_ins_gps_pack(
    uint8_t *dst_p,
    const struct ucr_01_ins_gps_t *src_p,
    size_t size);

/**
 * Unpack message INS_GPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_ins_gps_unpack(
    struct ucr_01_ins_gps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from INS_GPS.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_ins_gps_init(struct ucr_01_ins_gps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_ins_gps_gnss_week_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_gps_gnss_week_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_gps_gnss_week_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_gps_gnss_seconds_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_gps_gnss_seconds_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_gps_gnss_seconds_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_gps_gnss_lat_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_gps_gnss_lat_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_gps_gnss_lat_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_gps_gnss_long_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_gps_gnss_long_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_gps_gnss_long_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_gps_gnss_height_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_gps_gnss_height_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_gps_gnss_height_is_in_range(double value);

/**
 * Pack message INS_IMU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_ins_imu_pack(
    uint8_t *dst_p,
    const struct ucr_01_ins_imu_t *src_p,
    size_t size);

/**
 * Unpack message INS_IMU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_ins_imu_unpack(
    struct ucr_01_ins_imu_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from INS_IMU.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_ins_imu_init(struct ucr_01_ins_imu_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_imu_north_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_north_vel_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_north_vel_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_imu_east_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_east_vel_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_east_vel_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_imu_up_vel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_up_vel_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_up_vel_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_imu_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_roll_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_roll_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_imu_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_pitch_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_pitch_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
double ucr_01_ins_imu_azimuth_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_azimuth_decode(double value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_azimuth_is_in_range(double value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_ins_imu_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_ins_imu_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_ins_imu_status_is_in_range(uint8_t value);

/**
 * Pack message BamoCarReTransmit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_bamo_car_re_transmit_pack(
    uint8_t *dst_p,
    const struct ucr_01_bamo_car_re_transmit_t *src_p,
    size_t size);

/**
 * Unpack message BamoCarReTransmit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_bamo_car_re_transmit_unpack(
    struct ucr_01_bamo_car_re_transmit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BamoCarReTransmit.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_bamo_car_re_transmit_init(struct ucr_01_bamo_car_re_transmit_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_bamo_car_re_transmit_motor_temp_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamo_car_re_transmit_motor_temp_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamo_car_re_transmit_motor_temp_raw_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_bamo_car_re_transmit_controller_temp_raw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamo_car_re_transmit_controller_temp_raw_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamo_car_re_transmit_controller_temp_raw_is_in_range(uint16_t value);

/**
 * Pack message PDMCurrent.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_pdm_current_pack(
    uint8_t *dst_p,
    const struct ucr_01_pdm_current_t *src_p,
    size_t size);

/**
 * Unpack message PDMCurrent.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_pdm_current_unpack(
    struct ucr_01_pdm_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PDMCurrent.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_pdm_current_init(struct ucr_01_pdm_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_accumulator_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_accumulator_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_accumulator_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_tcu_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_tcu_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_tcu_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_bamocar_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_bamocar_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_bamocar_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_pumps_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_pumps_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_pumps_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_tsal_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_tsal_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_tsal_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_daq_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_daq_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_daq_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_display_kvaser_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_display_kvaser_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_display_kvaser_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_current_shutdown_reset_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_current_shutdown_reset_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_current_shutdown_reset_current_is_in_range(uint8_t value);

/**
 * Pack message PDMReTransmit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_pdm_re_transmit_pack(
    uint8_t *dst_p,
    const struct ucr_01_pdm_re_transmit_t *src_p,
    size_t size);

/**
 * Unpack message PDMReTransmit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_pdm_re_transmit_unpack(
    struct ucr_01_pdm_re_transmit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PDMReTransmit.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_pdm_re_transmit_init(struct ucr_01_pdm_re_transmit_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_re_transmit_pdm_int_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_re_transmit_pdm_int_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_re_transmit_pdm_int_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t ucr_01_pdm_re_transmit_pdm_batt_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_re_transmit_pdm_batt_voltage_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_re_transmit_pdm_batt_voltage_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_re_transmit_global_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_re_transmit_global_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_re_transmit_global_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_re_transmit_total_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_re_transmit_total_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_re_transmit_total_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_re_transmit_internal_rail_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_re_transmit_internal_rail_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_re_transmit_internal_rail_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_pdm_re_transmit_reset_source_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pdm_re_transmit_reset_source_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pdm_re_transmit_reset_source_is_in_range(uint8_t value);

/**
 * Pack message PackPower.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_pack_power_pack(
    uint8_t *dst_p,
    const struct ucr_01_pack_power_t *src_p,
    size_t size);

/**
 * Unpack message PackPower.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_pack_power_unpack(
    struct ucr_01_pack_power_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from PackPower.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_pack_power_init(struct ucr_01_pack_power_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_pack_power_pack_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pack_power_pack_current_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pack_power_pack_current_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_pack_power_pack_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pack_power_pack_voltage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pack_power_pack_voltage_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_pack_power_pack_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_pack_power_pack_power_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_pack_power_pack_power_is_in_range(float value);

/**
 * Pack message BamoCarConverted.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_bamo_car_converted_pack(
    uint8_t *dst_p,
    const struct ucr_01_bamo_car_converted_t *src_p,
    size_t size);

/**
 * Unpack message BamoCarConverted.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_bamo_car_converted_unpack(
    struct ucr_01_bamo_car_converted_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BamoCarConverted.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_bamo_car_converted_init(struct ucr_01_bamo_car_converted_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_bamo_car_converted_motor_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamo_car_converted_motor_temp_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamo_car_converted_motor_temp_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_bamo_car_converted_controller_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_bamo_car_converted_controller_temp_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_bamo_car_converted_controller_temp_is_in_range(float value);

/**
 * Pack message LapInfo.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_lap_info_pack(
    uint8_t *dst_p,
    const struct ucr_01_lap_info_t *src_p,
    size_t size);

/**
 * Unpack message LapInfo.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_lap_info_unpack(
    struct ucr_01_lap_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from LapInfo.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_lap_info_init(struct ucr_01_lap_info_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t ucr_01_lap_info_time_ms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_lap_info_time_ms_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_lap_info_time_ms_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t ucr_01_lap_info_lap_num_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_lap_info_lap_num_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_lap_info_lap_num_is_in_range(uint8_t value);

/**
 * Pack message Power_Limit_Info1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_power_limit_info1_pack(
    uint8_t *dst_p,
    const struct ucr_01_power_limit_info1_t *src_p,
    size_t size);

/**
 * Unpack message Power_Limit_Info1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_power_limit_info1_unpack(
    struct ucr_01_power_limit_info1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Power_Limit_Info1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_power_limit_info1_init(struct ucr_01_power_limit_info1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_power_limit_info1_motor_rpm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_power_limit_info1_motor_rpm_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_power_limit_info1_motor_rpm_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t ucr_01_power_limit_info1_output_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_power_limit_info1_output_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_power_limit_info1_output_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_power_limit_info1_output_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_power_limit_info1_output_current_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_power_limit_info1_output_current_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t ucr_01_power_limit_info1_apps1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_power_limit_info1_apps1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_power_limit_info1_apps1_is_in_range(uint16_t value);

/**
 * Pack message Power_Limit_Info2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ucr_01_power_limit_info2_pack(
    uint8_t *dst_p,
    const struct ucr_01_power_limit_info2_t *src_p,
    size_t size);

/**
 * Unpack message Power_Limit_Info2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ucr_01_power_limit_info2_unpack(
    struct ucr_01_power_limit_info2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Power_Limit_Info2.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int ucr_01_power_limit_info2_init(struct ucr_01_power_limit_info2_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_power_limit_info2_pack_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_power_limit_info2_pack_current_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_power_limit_info2_pack_current_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float ucr_01_power_limit_info2_pack_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ucr_01_power_limit_info2_pack_power_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ucr_01_power_limit_info2_pack_power_is_in_range(float value);


#ifdef __cplusplus
}
#endif

#endif
